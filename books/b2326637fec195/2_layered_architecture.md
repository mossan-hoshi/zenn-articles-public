---
title: "2_多層アーキテクチャ"
---

# バランスを追求する 多層シティーのレイヤ建築
![](/images/20230329_software_architecture/2_layered_architecture.png)
*様々な機能を持つ、個性的で活気のある層が垂直に立ち並ぶ都市を、主人公は相互に接続されたプラットフォームを操作し、その調和とバランスを保つことを目指します。*


レイヤードシティでは、すべての建物が特定の目的に役立つように細心の注意を払って設計されています。他の都市と同様に、Layered Cityは美しく効率的な構造を持っています。意欲的な建築家である主人公は、都市のデザインの複雑さを探求し、その層状の建築の背後にある原則をよりよく理解するために旅に出ます。

## 基盤: インフラストラクチャ層
レイヤードシティの基盤には、都市全体の基盤となるインフラストラクチャレイヤーがあります。このレイヤーには、発電所、水処理施設、交通システムなど、市の運営をサポートする重要なサービスが含まれています。
```python
# インフラストラクチャ層: データベース アクセス
class Database:
    def connect(self):
        # データベースへの接続を確立する
        pass

    def disconnect(self):
        # データベースへの接続を切断する
        pass

    def execute_query(self, query):
        # クエリを実行する
        pass
```
主人公がインフラストラクチャレイヤーを調査すると、都市の重要なサービスを上位レイヤーから分離するように設計されていることがわかります。この分離により、インフラストラクチャへの変更が都市の他の部分に与える影響が最小限に抑えられ、安定性と保守性が促進されます。

## 心臓部: ビジネス ロジック層
インフラストラクチャレイヤーの上には、レイヤードシティの心臓部であるビジネスロジックレイヤーがあります。このレイヤーには、市の運営を管理するロジックとルールが含まれており、すべてがスムーズかつ効率的に実行されるようになっています。

```python

# ビジネス ロジック層: サービス
class UserService:
    def create_user(self, user_data):
        # 検証とビジネス ロジックを実行する
        pass

    def update_user(self, user_id, user_data):
        # 検証とビジネス ロジックを実行する
        pass
```

主人公がビジネスロジックレイヤーを詳しく調べると、それが市のサービスとプロセスを調整する役割を担っていることがわかります。この層は、関心事の明確な分離を強制するため、開発者は下位層の複雑さに気を取られることなく、ビジネスルールの実装に集中できます。

## 表面: プレゼンテーション層
階層化された都市の最上位層はプレゼンテーション層で、住民や訪問者が都市をどのように認識するかを担当します。このレイヤーは、公共スペースのデザインからさまざまなアプリケーションのインターフェイスまで、すべてを網羅する美学とユーザー エクスペリエンスに関するものです。

```python
# プレゼンテーション層: ユーザー インターフェイス
class UserInterface:
    def display_user(self, user_data):
        # ユーザーデータを画面にレンダリングする
        pass

    def display_error(self, error_message):
        # ユーザーにエラーメッセージを表示する
        pass
```

主人公は、住民が都市をアクセスしやすく楽しいものにするために、プレゼンテーション層が重要であることを学びます。ユーザー エクスペリエンスとプレゼンテーションに重点を置くことで、このレイヤーは都市が機能的で視覚的にも魅力的であることを保証します。

## レイヤード アーキテクチャの利点
主人公は、層状都市のアーキテクチャの多くの利点を理解するようになります。都市を個別のレイヤーに編成することで、理解、維持、スケーリングが容易になります。各レイヤーは独立して進化できるため、都市はシステム全体を混乱させることなく、変化する要件やテクノロジーに適応できます。

## デメリットと対策
ただし、Layered Cityには課題がないわけではありません。主人公は、階層構造に厳密に従うと、複雑さが増し、パフォーマンスが低下する場合があることに気付きます。これらの問題に対処するために、彼らはマイクロサービス アーキテクチャのようなより柔軟なモジュラー アーキテクチャを採用するなど、別のアプローチを検討しています。

## 結論
階層化された都市を旅する主人公は、階層化されたアーキテクチャの原則とトレードオフについて貴重な洞察を得ることができます。関心の分離の重要性と厳密な階層化の潜在的な課題を理解することで、堅牢で適応性のあるシステムを設計するための準備が整います。

```mermaid
classDiagram
    class InfrastructureLayer {
        +connect()
        +disconnect()
        +execute_query(query)
    }
    class BusinessLogicLayer {
        +create_user(user_data)
        +update_user(user_id, user_data)
    }
    class PresentationLayer {
        +display_user(user_data)
        +display_error(error_message)
    }
    BusinessLogicLayer --|> InfrastructureLayer : 依存する
    PresentationLayer --|> BusinessLogicLayer : 依存する
```

## [付録] クリーンアーキテクチャ/オニオンアーキテクチャとの比較
多層アーキテクチャ同様に多層構造であるクリーンアーキテクチャやオニオンアーキテクチャとの比較結果を以下の表にまとめます。なお、クリーンアーキテクチャとオニオンアーキテクチャはこの比較項目に関してはほぼ同じ内容となるため、列を1つにまとめています。

| 特性                     | 多層アーキテクチャ                         | クリーンアーキテクチャ/<br/>オニオンアーキテクチャ |
| :------------------------: | :------------------------------------------: | :--------------------------------------------------: |
| **レイヤーの構成**           | 固定的な階層構造                           | 円状のレイヤー構造                                 |
| **依存関係の方向**           | 上位レイヤーが下位レイヤーに依存           | 内側のレイヤーに向かって依存                       |
| **ドメインロジックの位置**   | 中間レイヤーに配置されることが一般的       | ドメインレイヤーが中心に配置される                 |
| **テストの容易性**           | 依存関係によりテストが困難になる場合がある | テストが容易                                       |
| **フレームワーク依存**       | 外部フレームワークに依存する場合がある     | 依存関係逆転の原則(DIP)により<br/>フレームワークに依存しない   |
| **柔軟性**                   | 柔軟性に欠ける場合がある                   | 高い柔軟性                                         |
| **再利用性**                 | 再利用性に限定的                           | 高い再利用性                                       |
| **スケーラビリティ**         | 変更や拡張が困難な場合がある               | 高いスケーラビリティ                               |
| **コンポーネントの分離**     | 分離が不十分な場合がある                   | 明確なコンポーネント分離                           |
| **プラグイン可能性**         | 限定的                                     | 高いプラグイン可能性                               |
| **疎結合性**                 | 疎結合性に欠ける場合がある                 | 高い疎結合性                                       |
| **開発速度**                 | 速度低下の要因が存在する場合がある         | 開発速度が向上する可能性がある                     |
| **コードの読みやすさ**       | 複雑性が増すことがある                     | 高いコードの読みやすさ                             |
| **追加機能の容易性**         | 追加機能の導入が困難な場合がある           | 追加機能の導入が容易                               |
| **メンテナンス**             | メンテナンスが困難になる可能性がある       | メンテナンスが容易                                 |
| **アーキテクチャの適用範囲** | より限定的な適用範囲                       | 幅広い適用範囲                                     |
