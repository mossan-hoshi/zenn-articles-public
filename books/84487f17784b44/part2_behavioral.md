---
title: "第2部 振る舞い（Behavioral）についてのパターン"
---


# 第2部 振る舞い（Behavioral）についてのパターン
ビヘイビアデザインパターンは、オブジェクト間の相互作用を管理するのに役立ち、複雑なシステムの簡素化、メモリ使用の最適化、オブジェクトへのアクセス制御などのソリューションを提供します。これらのパターンを理解し適用することで、より柔軟で保守性の高い、効率的なソフトウェアシステムを実現できます。


| デザインパターン名      | ユースケース例                                   |
| :---------------------- | :----------------------------------------------- |
| Adapter                 | 既存クラスのインタフェース変更                   |
| Bridge                  | 抽象化と実装の分離                               |
| Composite               | 階層的なオブジェクト構造                         |
| Decorator               | ランタイムでオブジェクト機能追加                 |
| Facade                  | サブシステムの統合インタフェース                 |
| Flyweight               | 複数の共有オブジェクト利用                       |
| Proxy                   | アクセス制御やリソースの遅延読み込み             |

# アダプタ 互換性のないインタフェースを接続する
Adapterパターンは、互換性のない2つのインタフェースを一緒に使えるようにする構造設計パターンです。これは、ターゲットインタフェースを実装し、被アダプタクラスへの参照を保持するアダプタクラスを導入することによって実現されます。アダプタクラスは、ターゲットインタフェースからのメソッド呼び出しを、 アダプタクラスの適切なメソッドに変換する。

アダプタパターンは、互換性のないインタフェースをもつコンポーネントを統合する必要がある場合や、コンポーネントのインタフェースを異なるコンテキストに適合させる必要がある場合に有用です。アダプタを使用することで、クライアントコードは何も変更することなく、ターゲットインタフェースを通してアダプティーと対話でき、より高い柔軟性と再利用性を可能にします。

- [2_1_adapter「アダプターパターンで調和するジャングル」](./2_1_adapter)

# ブリッジ 抽象化と実装を切り離す
Bridgeパターンは、抽象化と実装を分離し、両者が独立して進化することを可能にする構造設計パターンである。これは、抽象化を表す抽象クラスと実装を表すインタフェースを導入することで実現されます。抽象クラスは実装インタフェースへの参照を保持し、メソッドの呼び出しを委譲する。

Bridgeパターンは、複雑なクラス階層を、抽象化用と実装用の2つの直交する階層に分離する必要がある場合に有効です。Bridgeを使用することで、クライアントコードは実装の詳細を気にすることなく抽象化を使用でき、より柔軟で保守性の高いコードを実現できます。

- [2_2_bridge「統一された努力で島の架け橋になる」](./2_2_bridge)

# コンポジット オブジェクトをツリー構造として扱う
Compositeパターンは、オブジェクトを木構造に構成し、個々のオブジェクトと構成を統一的に扱えるようにする構造設計パターンである。親子関係を管理するメソッドをもつComponentインタフェースと、このインタフェースを実装する1つ以上の具象クラスを導入することで実現する。

Compositeパターンは、部分と全体の階層を表現する必要がある場合や、クライアントコードが個々のオブジェクトとそのコンポジションを一貫した方法で扱う必要がある場合に有用である。Compositeを使用することで、クライアントコードは、個々のオブジェクトとその構成を区別することなく、ツリー構造内のオブジェクトと対話でき、コードを簡素化し、保守性を向上させることができます。

- [2_3_composite「雪の森のユナイテッドツリー」](./2_3_composite)

# デコレーター： 追加の責任でオブジェクトを強化する
Decoratorパターンは、オブジェクトの既存の動作に影響を与えることなく、追加の責任で動的に拡張することを可能にする構造設計パターンです。これは、装飾するオブジェクトと同じインタフェースを実装し、そのオブジェクトへの参照を保持するDecoratorクラスを導入することによって実現されます。デコレータークラスは、インタフェースのメソッドをオーバーライドし、その呼び出しをデコレートされたオブジェクトに委譲し、必要に応じて動作を追加・変更します。

Decoratorパターンは、継承を行わずにオブジェクトの機能を拡張する必要がある場合や、オブジェクトに "Decorator "を追加する必要がある場合に有効です。Decoratorを使用することで、クライアントコードはオブジェクトに新しい機能を持たせることができ、その機能は維持されます。を、より柔軟で再利用可能なコードに変更できます。

- [2_4_decorator「クリスマスツリーの飾りが命を宿す不思議な話」](./2_4_decorator)

# ファサード 複雑なサブシステムを簡素化する
Facadeパターンは、複雑なサブシステムに簡素化されたインタフェースを提供する動作設計パターンである。これは、Facadeクラスを導入することで実現され、サブシステムを使いやすくするための上位レベルのインタフェースとして機能する。Facadeクラスはサブシステムの複雑さをカプセル化し、クライアントコードが単一の簡素化されたインタフェースを通してサブシステムと対話することを可能にします。

Facadeパターンは、多くのコンポーネントや複雑な依存関係をもつ大規模なシステムやライブラリを扱う場合に、特に有用です。Facadeを使用することで、クライアントコードはサブシステムの複雑性から遮断され、理解や保守が容易になります。さらに、Facadeはサブシステムをクライアントコードから切り離すのに役立ち、システムの柔軟性と再利用性を向上させることができる。

- [2_5_facade「壁の向こうの秘密の世界への入り口を探す子供たちの冒険」](./2_5_facade)

# フライウェイト メモリフットプリントを削減する
Flyweightパターンは、複数のインスタンス間で共通部分を共有することで、オブジェクトのメモリ使用量を最小化することを目的とした動作設計パターンである。これは、共有オブジェクトの共通メソッドを定義したFlyweightインタフェースと、このインタフェースを実装した1つまたは複数の具体的なFlyweightクラスを導入することによって実現されます。共有オブジェクトはFlyweight Factoryによって管理され、固有のFlyweightのインスタンスが1つだけ作成されるようにします。

Flyweightパターンは、ゲームのグラフィック要素やドキュメントエディタのテキスト文字など、似たような特性をもつオブジェクトを大量に作成する必要がある場合に特に有効です。Flyweightを使用することで、メモリ使用量を大幅に削減でき、パフォーマンスとスケーラビリティの向上につながる。

- [2_6_flyweight「蜂の巣で働くハチたちが効率よく花の蜜を集める物語」](./2_6_flyweight)

# プロキシ オブジェクトへのアクセスを制御する
プロキシパターンは、別のオブジェクトの代用オブジェクトやプレースホルダーを提供し、元のオブジェクトへのアクセスを制御する動作設計パターンである。これは、元のオブジェクトと同じインタフェースをもつプロキシクラスと、元のオブジェクトへの参照を導入することで実現されます。プロキシクラスは、元のオブジェクトへのすべての呼び出しを傍受し、呼び出しを転送する前または後に追加のアクションを実行できるようにします。

プロキシパターンは、セキュリティチェック、ロギング、キャッシュの提供など、さまざまなシナリオで役立ちます。プロキシを使用することで、クライアントコードは実行される追加アクションを意識することなく元のオブジェクトと対話でき、よりモジュール化された保守性の高いシステムを実現できます。

- [2_7_proxy「おとぎ話の世界で他のキャラクターに化ける魔法使いの冒険」](./2_7_proxy)
