---
title: "第3部 構造（Structural）についてのパターン"
---

# 第3部 構造（Structural）についてのパターン
構造デザインパターンは、クラスやオブジェクトを構成し、より大きな構造を形成することに重点を置いたGoFデザインパターンのカテゴリです。これらのパターンは、より柔軟で拡張性の高いシステムを作るために、オブジェクトとクラスを組み合わせる効率的な方法を特定することによって、設計を簡素化します。構造パターンは、コンポーネント間の関係がうまく整理され、適切に抽象化されるようにすることで、再利用性、保守性、スケーラビリティを促進します。


| デザインパターン名      | ユースケース例                      |
| :---------------------- | :---------------------------------- |
| Chain of Responsibility | 複数のオブジェクト間で処理分散      |
| Command                 | オブジェクトに対する操作の履歴管理  |
| Interpreter             | 文法規則に基づくオブジェクト評価    |
| Iterator                | 集合オブジェクトの反復処理          |
| Mediator                | オブジェクト間の相互作用の調整      |
| Memento                 | オブジェクトの状態の保存・復元      |
| Observer                | オブジェクト間の状態同期            |
| State                   | オブジェクトの状態に応じた振る舞い  |
| Strategy                | 振る舞いの切り替え                  |
| Template                | Method	アルゴリズムのスケルトン定義 |
| Visitor                 | オブジェクト構造に対する操作追加    |

## chain_of_responsibility（チェーン・オブ・レスポンシビリティ）
Chain of Responsibility（責任の連鎖）とは、オブジェクトがリクエストをハンドラ候補の連鎖に乗せて、いずれかのハンドラが処理するまで渡すことを可能にする動作設計パターンです。このパターンは、リクエストの送信者とその受信者を切り離し、緩やかな結合と責任の分離を促進します。このパターンは、複雑なリクエストや階層的なリクエストを処理する場合に特に有効です。

- [3_1_chain_of_responsibility「ドミノ倒しで繋がる小さな動物たちの協力物語」](./3_1_chain_of_responsibility)

## command（コマンド）
コマンドは、リクエストを、リクエストに関するすべての情報を含む独立したオブジェクトに変換する動作設計パターンです。この変換により、リクエストは保存され、渡され、あとで実行されます。Commandパターンは、undo/redo機能、タスクキュー、そのほかの遅延実行シナリオを実装する際に特に有用です。

- [3_2_command「時間を操る時計を使って歴史を守るタイムトラベラーの物語」](./3_2_command)

## interpreter（インタープリター）
インタプリタとは、ドメイン固有の言語や式を解釈する方法を提供する動作設計パターンです。このパターンでは、言語の文法と、その言語の式を評価するインタプリタを定義する。Interpreterパターンは、ドメイン固有言語のパーサ、コンパイラー、インタプリターを実装する際に有用で、特に複雑な文法規則や再帰的な文法規則がある場合に有効です。

- [3_3_interpreter「言語を操る魔法使いが世界の謎を解き明かす冒険」](./3_3_interpreter)

## iterator（イテレータ）
Iteratorは、基本的な表現を公開することなくコレクションの要素にアクセスする方法を提供する動作設計パターンです。Iteratorパターンは、コレクションの要素を走査するための抽象化を導入し、共通のインタフェースを使用して異なるコレクションタイプにアクセスできます。このパターンは、クライアントコードを簡素化し、懸念事項の分離を促進します。

- [3_4_iterator「珍しい植物を探すため、園芸家が庭園を巡る物語」](./3_4_iterator)

## mediator（Mediator）
Mediatorは、通信の中心点を導入することで、コンポーネント間の結合を低減する動作設計パターンです。Mediatorパターンは、コンポーネント間の多対一の関係を促進し、各コンポーネントはMediatorとのみ通信を行って、Mediatorはコンポーネント間の相互作用を調整する。このパターンは、複雑な相互作用を管理し、疎結合を促進し、コンポーネントの保守性と再利用性を向上させるのに特に有効です。

- [3_5_mediator「対立する部族が仲介者の力で和解を目指す物語」](./3_5_mediator)

## memento（メメント）
Mementoは、オブジェクトのカプセル化に違反することなく、オブジェクトの内部状態をキャプチャして復元することを可能にする動作設計パターンです。Mementoパターンは、アンドゥ/リドゥ機能の実装や、異なる時点のオブジェクトの状態のスナップショットの作成に特に役立ちます。このパターンでは、状態を保存するために別のMementoオブジェクトを導入し、元のオブジェクトのカプセル化を維持します。

- [3_6_memento「失われた記憶を取り戻すためのタイムカプセルを発見する友達の物語」](./3_6_memento)

## observer（オブザーバー）
Observerは、オブジェクト間の一対多の依存関係を定義する行動デザインパターンであり、あるオブジェクト（主体）の変更が自動的にその依存オブジェクト（オブザーバ）の更新を誘発するようなものです。このパターンは、オブジェクトが共有する主体を介して間接的に通信することを可能にすることで、疎結合を促進します。Observerパターンは、イベント駆動型システムやUIフレームワークでデータバインディングを実装する際によく使用されます。

- [3_7_observer「天文台で働く若者が星の動きによるサインを解読する物語」](./3_7_observer)

## state（状態）
Stateは、オブジェクトの内部状態が変化したときに、その動作を変化させることを可能にする動作設計パターンです。このパターンでは、可能性のある状態ごとに特定の動作をカプセル化した個別の状態オブジェクトを導入することで、懸念事項の分離を促進し、複雑さを軽減しています。Stateパターンは、有限ステートマシンの実装や、オブジェクトの複雑な状態遷移を管理する場合に特に有効です。

- [3_8_state「感情によって能力が変わるスーパーヒーローの冒険」](./3_8_state)

## strategy（ストラテジー）
Strategyは、アルゴリズムのファミリーを定義し、それぞれをカプセル化し、互換性を持たせる動作設計パターンです。このパターンにより、クライアントは実行時に適切なアルゴリズムを選択でき、疎結合と柔軟性を促進できます。Strategyパターンは、複数のアルゴリズムを互換的に使用できる場合や、アルゴリズムの選択が実行時の条件に依存する場合に特に有効です。

- [3_9_strategy「チェス大会で優勝を目指す少年の戦略的な物語」](./3_9_strategy)

## template_method（テンプレート・メソッド）
テンプレートメソッドとは、アルゴリズムの骨格を基底クラスで定義し、一部のステップをサブクラスに委ねる動作設計パターンです。このパターンでは、サブクラスがアルゴリズムの全体構造を変えることなく、特定のステップを再定義できます。テンプレート・メソッドは、派生クラスでのカスタマイズを可能にしながら、共通の動作を基本クラスに抽出することで、コードの再利用と懸念事項の分離を促進します。

- [3_10_template_method「料理学校で独自のレシピを発展させる生徒たちの物語」](./3_10_template_method)

## visitor（訪問者）
Visitorは、オブジェクトそのものを変更することなく、既存のオブジェクト構造に新しい操作を追加することを可能にする動作設計パターンです。このパターンでは、新しい操作を実装した別のビジターオブジェクトを導入し、元のオブジェクトはビジターを受け入れて操作を委譲します。ビジターパターンは、異種オブジェクトの集まりで操作を行う場合や、新しい操作を頻繁に追加する必要がある場合に特に有効です。

- [3_11_visitor](./3_11_visitor)